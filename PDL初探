PDL：Problem Description Language
计概上机时做过测试，这学期就遇到了，写着很不习惯
三道题都是搜索
A:找相同数
总时间限制: 1000ms 内存限制: 65536kB

描述

在长度为n（1<=n<=1000）的整数（每个整数在0~10000之间）序列中，找到出现了两次的数。

输入

第一行输入一个整数n
第二行输入序列，用空格分开

输出

出现了两次的数，保证存在且唯一

样例输入

4
1 2 4 2
样例输出

2
我们可以发现常规做法可能重在储存信息来减小复杂度
而PDL则基于的是搜索的思想

#input
	n of int in [1,1000];
	num of (int in [0,10000])[1~n];
#required
	i of int in [1,n];
	j of int in [1,n];
	num[i]=num[j] and i<j;
#output
num[i];

B:旅行商问题
总时间限制: 1000ms 内存限制: 65536kB

描述

某国家有n（1<=n<=10）座城市，给定任意两座城市间距离（不超过1000的非负整数）。一个旅行商人希望访问每座城市恰好一次（出发地任选，且最终无需返回出发地）。求最短的路径长度。

输入

第一行输入一个整数n
接下来n行，每行n个数，用空格隔开，以邻接矩阵形式给出城市间距离。该邻接矩阵是对称的，且对角线上全为0

输出

一行，最短路径的长度

样例输入

6
0 16 1 10 12 15
16 0 10 2 10 8
1 10 0 10 5 10
10 2 10 0 9 3
12 10 5 9 0 8
15 8 10 3 8 0
样例输出

19
#input
	n of int in[1,10];
	distance of (int in [0,1000])[1~n][1~n];
#required
	 a of (int in [1,n])[1~n];
	alldiff a;
#objective
	minimize summation[distance[a[i]][a[i+1]]:forall i (i of int in [1,n-1])];

C:团队合作
总时间限制: 1000ms 内存限制: 65536kB

描述

你需要挑选若干成员组建一个工作团队。现有n（1<=n<=100）名候选人，每个人有一个“凝聚力”和一个“工作能力”（均为-50至50的整数）。要确保团队能够顺利合作，所有成员的“凝聚力”之和必须为正。在这个条件下，团队的总“工作能力”最大是多少？保证至少存在一个满足条件且总“工作能力”为正的团队。

输入

第一行输入一个整数n
第二行输入n个整数，用空格隔开，依次为各候选人的凝聚力
第三行输入n个整数，用空格隔开，依次为各候选人的工作能力

输出

一个整数，最大的团队总“工作能力”

样例输入

5
-5 8 6 2 -8
7 -6 -3 1 -5
样例输出

5
#input
	n of int in[1,100];
	co of (int in[-50,50])[1~n];
	po of(int in[-50,50])[1~n];
#required
	ans of(int in [1,n]){};
	summation[co[i]:forall i (i in ans)]>0;
#objective
	maximize summation [po[i]:forall i(i in ans)];
